fof(stoppedin_defn,conjecture,! [Time1] : ! [Fluent] : ! [Time2] : ( stoppedIn(Time1,Fluent,Time2) <=> ? [Event] : ? [Time] : ( happens(Event,Time) & less(Time1,Time) & less(Time,Time2) & terminates(Event,Fluent,Time) ) ) ).
fof(startedin_defn,conjecture,! [Time1] : ! [Time2] : ! [Fluent] : ( startedIn(Time1,Fluent,Time2) <=> ? [Event] : ? [Time] : ( happens(Event,Time) & less(Time1,Time) & less(Time,Time2) & initiates(Event,Fluent,Time) ) ) ).
fof(change_holding,conjecture,! [Event] : ! [Time] : ! [Fluent] : ! [Fluent2] : ! [Offset] : ( ( happens(Event,Time) & initiates(Event,Fluent,Time) & less(n0,Offset) & trajectory(Fluent,Time,Fluent2,Offset) & ~ stoppedIn(Time,Fluent,plus(Time,Offset)) ) => holdsAt(Fluent2,plus(Time,Offset)) ) ).
fof(antitrajectory,conjecture,! [Event] : ! [Time1] : ! [Fluent1] : ! [Time2] : ! [Fluent2] : ( ( happens(Event,Time1) & terminates(Event,Fluent1,Time1) & less(n0,Time2) & antitrajectory(Fluent1,Time1,Fluent2,Time2) & ~ startedIn(Time1,Fluent1,plus(Time1,Time2)) ) => holdsAt(Fluent2,plus(Time1,Time2)) ) ).
fof(keep_holding,conjecture,! [Fluent] : ! [Time] : ( ( holdsAt(Fluent,Time) & ~ releasedAt(Fluent,plus(Time,n1)) & ~ ( ? [Event] : ( happens(Event,Time) & terminates(Event,Fluent,Time) ) ) ) => holdsAt(Fluent,plus(Time,n1)) ) ).
fof(keep_not_holding,conjecture,! [Fluent] : ! [Time] : ( ( ~ holdsAt(Fluent,Time) & ~ releasedAt(Fluent,plus(Time,n1)) & ~ ( ? [Event] : ( happens(Event,Time) & initiates(Event,Fluent,Time) ) ) ) => ~ holdsAt(Fluent,plus(Time,n1)) ) ).
fof(keep_released,conjecture,! [Fluent] : ! [Time] : ( ( releasedAt(Fluent,Time) & ~ ( ? [Event] : ( happens(Event,Time) & ( initiates(Event,Fluent,Time) | terminates(Event,Fluent,Time) ) ) ) ) => releasedAt(Fluent,plus(Time,n1)) ) ).
fof(keep_not_released,conjecture,! [Fluent] : ! [Time] : ( ( ~ releasedAt(Fluent,Time) & ~ ( ? [Event] : ( happens(Event,Time) & releases(Event,Fluent,Time) ) ) ) => ~ releasedAt(Fluent,plus(Time,n1)) ) ).
fof(happens_holds,conjecture,! [Event] : ! [Time] : ! [Fluent] : ( ( happens(Event,Time) & initiates(Event,Fluent,Time) ) => holdsAt(Fluent,plus(Time,n1)) ) ).
fof(happens_terminates_not_holds,conjecture,! [Event] : ! [Time] : ! [Fluent] : ( ( happens(Event,Time) & terminates(Event,Fluent,Time) ) => ~ holdsAt(Fluent,plus(Time,n1)) ) ).
fof(happens_releases,conjecture,! [Event] : ! [Time] : ! [Fluent] : ( ( happens(Event,Time) & releases(Event,Fluent,Time) ) => releasedAt(Fluent,plus(Time,n1)) ) ).
fof(happens_not_released,conjecture,! [Event] : ! [Time] : ! [Fluent] : ( ( happens(Event,Time) & ( initiates(Event,Fluent,Time) | terminates(Event,Fluent,Time) ) ) => ~ releasedAt(Fluent,plus(Time,n1)) ) ).
